Skills: não usei `skill-creator`/`skill-installer` porque a tarefa é auditoria técnica do backend/n8n, não criação/instalação de skills.

## 1) Executive Summary
1. O backend já está em um bom “modular monolith” por contexto (`payments`, `orders`, `pairing`, `provisioning`, `security`, `config`), com base suficiente para evolução incremental.
2. Há idempotência parcial no webhook por `payment_id` único, mas falta deduplicação por evento (`eventId`), tratamento explícito de `out-of-order` e máquina de estados mais rígida.
3. O fluxo crítico funciona: checkout cria `order`, webhook consulta MP, decide `PROVISION|WAIT|DENY|IGNORE`, e provisioning gera link de pairing.
4. Resiliência está abaixo do necessário para padrão fintech: `WebClient` sem timeout/retry/backoff explícitos em chamadas MP/Evolution.
5. Segurança está funcional via ApiKey e token de webhook, mas há gaps: validação de assinatura MP ausente, log com potencial vazamento de token/segredo, e inconsistência GET/POST no webhook.
6. Observabilidade ainda mínima: não há `correlationId/runId` propagado no backend, nem métricas de negócio para fluxo de pagamento/pairing.
7. Testes são insuficientes para risco financeiro: quase não há cobertura de integração para replay, duplicidade, concorrência e falhas de rede.
8. A recomendação é evoluir em 3 fases: MVP estável, hardening transacional/idempotente, observabilidade+segurança avançada.
9. A evolução para clean/hex deve ser incremental, sem refactor amplo: introduzir use cases e ports nos fluxos críticos primeiro.
10. Tudo proposto como novo está marcado como **NOVO**.

## 2) AS-IS (como está hoje)

### 2.1 Mapa de pacotes/módulos e responsabilidades
| Módulo | Responsabilidade atual | Evidências |
|---|---|---|
| `payments` | Checkout MP, webhook MP, decisão de negócio e persistência `payments` | [PaymentsController.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/api/PaymentsController.java), [CheckoutService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/CheckoutService.java), [MercadoPagoWebhookService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoWebhookService.java), [MercadoPagoPaymentTxService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoPaymentTxService.java) |
| `orders` | Estado da ordem (`CREATED`, `PAID`, `PROVISIONED`, `CANCELED`) | [OrderEntity.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/orders/OrderEntity.java), [OrderStatus.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/orders/OrderStatus.java) |
| `pairing` | Sessão/token/status de pairing e endpoints internos | [PairingService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/pairing/PairingService.java), [PairingInternalController.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/pairing/PairingInternalController.java) |
| `provisioning` | Orquestra provisionamento pós-pagamento e página pública `/pair/{token}` | [ProvisioningService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/provisioning/ProvisioningService.java), [PairingPublicController.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/provisioning/PairingPublicController.java), [EvolutionClient.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/provisioning/EvolutionClient.java) |
| `security` | Proteção por ApiKey com exceções de rotas públicas | [SecurityConfig.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/security/SecurityConfig.java), [ApiKeyAuthFilter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/security/ApiKeyAuthFilter.java) |
| `config` + `properties` | Beans e configs de WebClient/properties | [WebClientConfig.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/config/WebClientConfig.java), [MercadoPagoProperties.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/config/properties/MercadoPagoProperties.java) |
| `shared` | Enum de plano e tratamento global de exceções | [PlanId.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/shared/domain/PlanId.java), [GlobalExceptionHandler.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/shared/exception/GlobalExceptionHandler.java) |
| `db/migration` | Flyway para schema de `orders`, `payments`, `pairing_sessions` | [V1__init.sql](/mnt/c/repositorio/com.shkgroups.agent/src/main/resources/db/migration/V1__init.sql), [V4__align_schema_to_entities.sql](/mnt/c/repositorio/com.shkgroups.agent/src/main/resources/db/migration/V4__align_schema_to_entities.sql), [V6__payments_unique_payment_id.sql](/mnt/c/repositorio/com.shkgroups.agent/src/main/resources/db/migration/V6__payments_unique_payment_id.sql) |

### 2.2 Endpoints existentes (método + path + DTOs principais)
| Método | Path | DTO principal | Auth AS-IS | Status/retorno AS-IS |
|---|---|---|---|---|
| `POST` | `/v1/payments/checkout` | `CheckoutCreateRequest` -> `CheckoutCreateResponse` | ApiKey | `200`, erros via `ProblemDetail` |
| `GET/POST` | `/v1/payments/mercadopago/notification` | query/body livre -> `MercadoPagoWebhookResponse` | `POST` público; `GET` cai em ApiKey (inconsistência) | sempre retorna corpo de decisão (`IGNORE/WAIT/DENY/PROVISION`) |
| `POST` | `/v1/provisioning/whatsapp/pairing` | `ProvisionPairingRequest` -> `ProvisionPairingResponse` | ApiKey | `200`; `404/409/500` por `ProvisioningException`; demais `ProblemDetail` |
| `GET` | `/pair/{token}` | HTML (`pairing.html`) | público | `200` HTML ou erro por token inválido/expirado |
| `POST` | `/internal/pairing/orders/{orderId}/create` | `PairingCreateRequest` | ApiKey | `200` |
| `POST` | `/internal/pairing/orders/{orderId}/resend` | sem body | ApiKey | `200` |
| `POST` | `/internal/pairing/tokens/{token}/ready` | `PairingReadyRequest` | ApiKey | `200` |
| `POST` | `/internal/pairing/instances/{instance}/paired` | sem body | ApiKey | `200` |
| `GET` | `/internal/pairing/tokens/{token}` | sem body | ApiKey | `200` |
| `GET` | `/actuator/health`, `/actuator/info` | n/a | público | `200` |

### 2.3 Fluxo atual (sequência textual)
1. n8n chama `POST /v1/payments/checkout`.
2. Backend cria `orders.status=CREATED` e chama MP para criar preferência.
3. MP processa pagamento.
4. Webhook chega em `/v1/payments/mercadopago/notification` (ou via n8n intermediando, dependendo de `notification-url` configurada).
5. Backend valida token, consulta pagamento no MP, faz upsert em `payments`, atualiza `orders` para `PAID` quando aplicável e retorna decisão.
6. n8n interpreta decisão; quando `PROVISION`, chama `POST /v1/provisioning/whatsapp/pairing`.
7. Backend cria/rota token de pairing, grava sessão, retorna `pairingUrl`.
8. Usuário abre `/pair/{token}`; backend tenta buscar QR na Evolution e marca sessão `READY`.
9. Callback interno (`/internal/pairing/instances/{instance}/paired`) marca sessão `PAIRED`.

---

## 3) Gaps priorizados (P0/P1/P2)

### P0
| Tema | Gap crítico AS-IS | Ação recomendada |
|---|---|---|
| Idempotência/consistência | Dedup só por `payment_id`; sem trilha por `eventId`; `out-of-order` não governado por máquina de estados explícita | **NOVO** `payment_events` (eventId + paymentId + receivedAt + source + status) com unicidade; justificativa: webhook at-least-once exige dedup de evento e auditoria de replay |
| Replays/falha de rede | Quando fetch MP falha, retorna `IGNORE/mp_fetch_failed`; sem sinalização HTTP retriable | **NOVO** mapear falhas transitórias para `503` (quando webhook direto MP) ou campo `retryable=true` (quando n8n); justificativa: evitar perda silenciosa de evento |
| Segurança webhook | Só token em query; sem validação de assinatura do provedor | **NOVO** validar assinatura/hmac do MP (quando disponível), mantendo token como fallback compatível; justificativa: reduzir spoofing |
| Segredo em log | `notificationUrl` com token pode ir para log | Remover token de logs e mascarar query sensível em logging; justificativa: proteção de segredo |

### P1
| Tema | Gap AS-IS | Ação recomendada |
|---|---|---|
| Contrato HTTP | `GET` webhook existe no controller, mas security libera só `POST` | Alinhar contrato (`POST` somente) ou liberar ambos conscientemente; manter compat por período de transição |
| DTO/validação | `ProvisionPairingRequest.remoteJid` obrigatório mas não é usado para validação real | Validar igualdade com `order.remoteJid` ou remover no contrato futuro com compat backward |
| Resiliência | WebClients sem timeout/retry/backoff explícitos | Configurar connect/read/response timeout + retry exponencial com jitter para MP/Evolution |
| Estado de ordem | `PROVISIONED` é marcado ao gerar link, não quando pairing efetivamente concluído | **NOVO** separar status de provisionamento e status de pairing final; justificativa: refletir estado de negócio com precisão |

### P2
| Tema | Gap AS-IS | Ação recomendada |
|---|---|---|
| Observabilidade | Sem `correlationId/runId` fim-a-fim; sem métrica de negócio | **NOVO** filtro MDC + propagação de headers + métricas (`webhook_received`, `webhook_dedup`, `provision_success`, `provision_fail`) |
| Config hygiene | `.env.example` desalinhado com `application-*.yml` (`APP_SECURITY_API_KEY` vs `APP_API_KEY_KEY`; variáveis n8n) | Ajustar documentação/env para evitar deploy quebrado |
| Testes | Cobertura muito baixa; teste unitário em `src/main/java` e testes fora de `src/test/java` | Reorganizar suíte e criar integração para fluxos críticos |

---

## 4) Blueprint do n8n (workflow final)

### 4.1 Nodes step-by-step (Webhook → Normalize → Switch → HTTP Requests → Error Path/DLQ)
1. `Webhook (MP)` recebe evento bruto.
2. `Function: Normalize` extrai `eventId`, `paymentId`, `topic`, `correlationId`, `runId`, `token`, `raw`.
3. `IF: Campos mínimos` valida `paymentId` e token.
4. **NOVO** `Data Store/Redis Dedup` por `eventId` (ou fallback `paymentId+topic+timestampBucket`); justificativa: reexecução segura no orquestrador.
5. `HTTP Request -> backend /v1/payments/mercadopago/notification` com headers `X-Correlation-Id`, `X-Run-Id`.
6. `Switch decision` em `PROVISION | WAIT_PAYMENT | DENY | IGNORE`.
7. `HTTP Request -> backend /v1/provisioning/whatsapp/pairing` apenas quando `PROVISION`.
8. `HTTP Request -> canal de notificação` para envio da mensagem final com `pairingUrl` quando provisionado.
9. `No-op/agenda` para `WAIT_PAYMENT`.
10. `No-op/feedback` para `DENY/IGNORE`.
11. `Error Trigger` captura falhas do workflow.
12. **NOVO** `DLQ Node` persiste evento + contexto e dispara alerta; justificativa: tratamento operacional de falhas não recuperáveis.

### 4.2 Payload mínimo entre nodes
```json
{
  "correlationId": "uuid-v4",
  "runId": "n8n-execution-id",
  "eventId": "mp-event-id-or-null",
  "orderId": "optional-until-resolved",
  "paymentId": "mp-payment-id",
  "planId": "agente_ia_start|agente_ia_pro|optional",
  "token": "webhook-token",
  "decision": "PROVISION|WAIT_PAYMENT|DENY|IGNORE",
  "reason": "string"
}
```

### 4.3 Reexecução segura (sem duplicar efeitos)
1. Dedup no n8n por `eventId` (**NOVO**) antes de chamar backend.
2. Backend mantém idempotência por `paymentId` (já existe) e evolui para evento (**NOVO**).
3. Provisioning deve ser idempotente por `orderId` e devolver mesmo resultado quando já provisionado.
4. Retries só em operações claramente transitórias; negar retry em erro de contrato (`4xx`).

### 4.4 Estratégia de erros (retry/backoff, DLQ/alerta)
1. `HTTP 5xx/timeouts`: retry exponencial (`3-5` tentativas, jitter).
2. `HTTP 4xx` de validação: não retry, enviar para DLQ com causa.
3. Exaustão de retry: enviar para DLQ + alerta Slack/Email/Pager.
4. DLQ deve armazenar `correlationId`, `runId`, payload normalizado e última stack curta.

### 4.5 Segurança no n8n
1. Credentials no cofre n8n; nunca token hardcoded em node.
2. ApiKey backend via credencial e header padrão.
3. Sanitizar logs do workflow para não expor token/query.
4. Segregar workflow interno (callbacks) de workflow público (webhook).

---

## 5) TO-BE incremental

### 5.1 Quão perto/longe de clean/hex hoje
1. Perto: separação por contexto já existe e controllers não estão gigantes.
2. Longe: services de aplicação acoplados a JPA/WebClient diretamente, sem ports explícitas.
3. Longe: contratos de integração externos (MP/Evolution) não estão abstraídos por portas estáveis.
4. Perto: pontos críticos já estão concentrados em poucos serviços, facilitando extração incremental.

### 5.2 Use Cases sugeridos
1. **NOVO** `CreateCheckoutUseCase`; justificativa: isolar regra de criação de ordem + preferência MP.
2. **NOVO** `ProcessMercadoPagoWebhookUseCase`; justificativa: centralizar idempotência, dedup de evento e transições de status.
3. **NOVO** `ProvisionPairingUseCase`; justificativa: separar negócio de provisionamento da infraestrutura de pairing.
4. **NOVO** `ResolvePairingQrUseCase`; justificativa: controlar retry/erro de Evolution fora do controller MVC.

### 5.3 Ports (interfaces) e adapters
1. **NOVO** `PaymentGatewayPort` -> adapter `MercadoPagoClient`.
2. **NOVO** `PairingQrProviderPort` -> adapter `EvolutionClient`.
3. **NOVO** `OrderStorePort`/`PaymentStorePort`/`PairingSessionStorePort` -> adapters JPA (`OrderRepository`, etc).
4. Inbound adapters continuam controllers atuais para preservar compatibilidade.

---

## 6) Plano de mudanças por arquivo/pacote

| Arquivo/Pacote | O que muda | Risco | Compatibilidade | Rollback |
|---|---|---|---|---|
| [PaymentsController.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/api/PaymentsController.java) | Alinhar método webhook (preferência `POST`) e enriquecer retorno para retry controlado | Médio | Manter path e payload atual | Reverter controller e manter fluxo antigo |
| [MercadoPagoWebhookService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoWebhookService.java) | Assinatura/token validation robusta; classificar erro transitório vs definitivo | Médio | Compatível se validação nova for feature-flag | Desligar flag e usar token-only |
| [MercadoPagoPaymentTxService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoPaymentTxService.java) | Regras de transição de estado e idempotência por evento | Alto | Preservar `MpDecision` | Voltar à regra atual por flag |
| [PaymentsEntity.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/PaymentsEntity.java) | Ajustes para auditoria/idempotência (sem quebrar colunas atuais) | Médio | Migração additive | Reverter uso de novas colunas |
| **NOVO** `/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/PaymentEventEntity.java` | Tabela de eventos webhook dedup | Médio | Aditivo | Ignorar leitura da nova tabela |
| **NOVO** `/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/PaymentEventRepository.java` | Repositório dedup por `eventId` | Baixo | Aditivo | Remover chamada ao repo |
| **NOVO** `/mnt/c/repositorio/com.shkgroups.agent/src/main/resources/db/migration/V8__payment_events_dedup.sql` | DDL de eventos + índices | Médio | Aditivo | Flyway forward fix (não remover migração aplicada) |
| [ProvisioningService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/provisioning/ProvisioningService.java) | Idempotência explícita e validação consistente de `remoteJid/plan` | Médio | Manter endpoint e response | Reverter regras novas por flag |
| [ProvisionPairingRequest.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/provisioning/dto/ProvisionPairingRequest.java) | Ajustar validação para refletir uso real do contrato | Baixo | Preferir transição backward compatible | Aceitar ambos formatos durante janela |
| [WebClientConfig.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/config/WebClientConfig.java) | Timeouts explícitos e estratégia de retry | Médio | Transparente para contrato HTTP externo | Retornar config antiga |
| [SecurityConfig.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/security/SecurityConfig.java) + [ApiKeyAuthFilter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/security/ApiKeyAuthFilter.java) | Harmonizar política do webhook, endurecer rotas internas, resposta de erro consistente | Médio | Sem mudar header/path atual | Reverter regras de autorização |
| [GlobalExceptionHandler.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/shared/exception/GlobalExceptionHandler.java) | Sanitização de logs/erros e taxonomy estável | Baixo | Mantém `ProblemDetail` | Voltar handler anterior |
| **NOVO** `/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/observability/CorrelationIdFilter.java` | `correlationId/runId` via MDC + headers | Baixo | Aditivo | Remover filtro do chain |
| [application-prod.yml](/mnt/c/repositorio/com.shkgroups.agent/src/main/resources/application-prod.yml), [application-dev.yml](/mnt/c/repositorio/com.shkgroups.agent/src/main/resources/application-dev.yml), [.env.example](/mnt/c/repositorio/com.shkgroups.agent/.env.example) | Alinhar nomes de variáveis e parâmetros de timeout/retry | Médio | Mantém aliases temporários para compat | Reverter env mapping |

---

## 7) Roadmap 3 fases

### Fase 1: MVP estável (pagamento aprovado → pairing confiável)
1. Corrigir inconsistência webhook GET/POST e contratos mínimos.
2. Garantir idempotência operacional por `paymentId` sem efeito duplicado em provisioning.
3. Sanear logs sensíveis (`notificationUrl`, tokens).
4. Entregar workflow n8n com `Normalize -> Switch -> Provision -> ErrorPath`.

### Fase 2: Hardening (idempotência completa, estados, retries)
1. **NOVO** dedup por `eventId` + tabela de eventos.
2. **NOVO** máquina de estados explícita para `orders/payments/pairing`.
3. Timeouts + retries/backoff com jitter para MP/Evolution.
4. Testes de concorrência/replay/out-of-order com banco real.

### Fase 3: Observabilidade/segurança avançada
1. **NOVO** `correlationId/runId` fim-a-fim backend+n8n.
2. Métricas de negócio e alertas (DLQ, taxa de IGNORE, falha de provisioning).
3. **NOVO** validação de assinatura webhook MP e hardening de rotas internas por contexto.

---

## 8) Plano de testes (unit/integration/manual)

1. Unit: `MpStatusEvaluator`, transições de `OrderStatus`, dedup/key builder de webhook, validação de token/assinatura.
2. Unit: `ProvisioningService` para cenários `order_not_found`, `order_not_paid`, `plan_mismatch`, idempotência.
3. Integration (Spring + Postgres/Testcontainers): replay do mesmo `paymentId`, eventos fora de ordem, concorrência de webhook simultâneo, retry de MP indisponível.
4. Integration: segurança de rotas (`/internal/**` bloqueado sem ApiKey, webhook conforme política definida).
5. Integration: contrato HTTP (`ProblemDetail`, status code consistente).
6. Manual: E2E com n8n webhook real, pagamento aprovado, provisionamento, abertura de `/pair/{token}`, callback de paired.
7. Manual: falha injetada (timeout MP/Evolution) para validar retry e DLQ.
8. Observação AS-IS: cobertura atual é muito baixa e mal posicionada (ex.: teste JUnit em `src/main/java`), precisa reorganização.

---

## 9) Comandos sugeridos (curto)

```bash
# build/test
mvn -q -DskipTests clean package
mvn -q test

# validação rápida de endpoints (ajustar host/chaves)
curl -i -X POST http://localhost:8080/v1/payments/checkout \
  -H "Content-Type: application/json" -H "X-Api-Key: <KEY>" \
  -d '{"instance":"inst1","remoteJid":"5511999999999@s.whatsapp.net","plan":"agente_ia_start","channel":"whatsapp","customer":{"name":"Fulano"}}'

curl -i -X POST "http://localhost:8080/v1/payments/mercadopago/notification?token=<TOKEN>&data.id=<PAYMENT_ID>"

curl -i -X POST http://localhost:8080/v1/provisioning/whatsapp/pairing \
  -H "Content-Type: application/json" -H "X-Api-Key: <KEY>" \
  -d '{"orderId":"<ORDER_ID>","remoteJid":"5511999999999@s.whatsapp.net","plan":"agente_ia_start","paymentId":"<PAYMENT_ID>"}'
```

