## 1) Executive Summary (10-15 linhas)
1. A Fase 1 existe para começar a migração para Clean/Hex sem risco de big-bang, isolando lógica de negócio dos fluxos críticos de pagamento em Use Cases.
2. Entram nesta fase apenas dois fluxos: `CreateCheckout` (`POST /v1/payments/checkout`) e `ProcessMercadoPagoWebhook` (`GET|POST /v1/payments/mercadopago/notification`).
3. Contratos HTTP permanecem idênticos: mesmos paths, mesmos DTOs de request/response, mesmos códigos esperados por comportamento atual.
4. Controllers viram inbound adapters finos: validação HTTP, extração de parâmetros e delegação para Use Case.
5. Introduzimos apenas as Ports mínimas: **NOVO** `PaymentGatewayPort`, **NOVO** `OrderStorePort`, **NOVO** `PaymentStorePort`.
6. Adapters de saída serão incrementais e pequenos: wrappers sobre `MercadoPagoClient`, `OrderRepository` e `PaymentRepository`.
7. Não entram na Fase 1: mudança de contrato, redesign de schema, dedup por `eventId`, reestruturação completa dos módulos de provisioning/pairing.
8. Riscos críticos atuais ficam explícitos: transação envolvendo chamada externa no checkout e tentativa de `upsert` com `orderId=null` no webhook.
9. Critério de sucesso técnico: `mvn test` verde + regressão de contrato (status/body) idêntica + replay de webhook sem efeito duplicado.
10. Critério de compatibilidade: nenhuma mudança no consumidor n8n para checkout/webhook.
11. Critério de rollback: reversão por PR (`git revert`) com serviços legados preservados como fallback durante a fase.

## 2) AS-IS — mapa de dependências REAL

### Fluxo 1: Checkout
Cadeia real:
`PaymentsController.checkout` -> `CheckoutService.createCheckout` -> `OrderRepository.save` + `MercadoPagoClient.createPreference` + `MercadoPagoProperties`.

Referências:
[PaymentsController.java:22](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/api/PaymentsController.java:22)  
[CheckoutService.java:30](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/CheckoutService.java:30)  
[MercadoPagoClient.java:40](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/mp/MercadoPagoClient.java:40)

Acoplamentos e riscos:
- Serviço de aplicação mistura regras de negócio + persistência + integração externa.
- `@Transactional` cobre chamada HTTP externa ao MP (`block()`), aumentando tempo de lock/rollback amplo.
- Campo `customer.name` é validado no request, mas não é persistido no `OrderEntity` no fluxo atual.
- Dependência direta em `MercadoPagoProperties` e construção de payload MP no serviço.

Transação e side effects:
- Transação aberta em todo `createCheckout`.
- Side effects: inserção de `orders`, chamada ao MP para preferência, log de criação.
- Em falha na chamada MP, rollback tende a cancelar inserção do pedido (comportamento atual).

### Fluxo 2: Webhook MP
Cadeia real:
`PaymentsController.mpNotification` -> `MercadoPagoWebhookService.process` -> `MercadoPagoClient.getPayment` -> `MercadoPagoPaymentTxService.handle` -> `PaymentRepository` + `OrderRepository`.

Referências:
[PaymentsController.java:27](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/api/PaymentsController.java:27)  
[MercadoPagoWebhookService.java:30](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoWebhookService.java:30)  
[MercadoPagoPaymentTxService.java:25](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoPaymentTxService.java:25)  
[PaymentRepository.java:16](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/PaymentRepository.java:16)

Acoplamentos e riscos:
- Token validation + integração MP + regra transacional estão espalhadas em 2 services.
- `payments.order_id` é `NOT NULL`, mas há caminho de `upsertPayment(..., orderId=null, ...)` em `no_external_reference`.
- `GET` webhook existe no controller, mas bypass de segurança está coerente só para `POST` (manter AS-IS na Fase 1 para não quebrar).
- Sem timeout/retry explícito no `WebClient` (risco operacional já existente, fora do escopo fechado da Fase 1).

Transação e side effects:
- Busca de pagamento no MP ocorre fora da transação.
- `handle` é transacional: upsert de `payments`, leitura/atualização de `orders`.
- Idempotência parcial: lock pessimista + índice único por `payment_id`.
- Transição de estado atual: `CREATED -> PAID`; decisão `PROVISION` retorna para orquestração externa.

## 3) TO-BE Fase 1 — arquitetura alvo incremental (somente fase 1)

Diagrama textual:
```text
HTTP Controller (inbound adapter)
  -> Application Use Case
    -> Ports (interfaces mínimas)
      -> Adapters (JPA / MercadoPago client)
        -> Infra atual (repositories, webclient)
```

Fluxos alvo:
```text
POST /v1/payments/checkout
PaymentsController -> CreateCheckoutUseCase
  -> OrderStorePort
  -> PaymentGatewayPort (createPreference)
  -> CheckoutCreateResponse (DTO atual)

GET|POST /v1/payments/mercadopago/notification
PaymentsController -> ProcessMpWebhookUseCase
  -> PaymentGatewayPort (getPayment)
  -> MercadoPagoPaymentTxService (transacional) usando OrderStorePort/PaymentStorePort
  -> MercadoPagoWebhookResponse (DTO atual)
```

Pacotes novos:
```text
com.shkgroups.application.payments
  - **NOVO** CreateCheckoutUseCase
  - **NOVO** ProcessMpWebhookUseCase

com.shkgroups.ports.payments
  - **NOVO** PaymentGatewayPort
  - **NOVO** OrderStorePort
  - **NOVO** PaymentStorePort

com.shkgroups.adapters.out.mercadopago
  - **NOVO** MercadoPagoGatewayAdapter (usa MercadoPagoClient existente)

com.shkgroups.adapters.out.persistence
  - **NOVO** JpaOrderStoreAdapter (wrapper OrderRepository)
  - **NOVO** JpaPaymentStoreAdapter (wrapper PaymentRepository)
```

Assinaturas sugeridas (blueprint):
```java
public final class CreateCheckoutUseCase {
  public CheckoutCreateResponse execute(CheckoutCreateRequest req);
}

public final class ProcessMpWebhookUseCase {
  public MercadoPagoWebhookResponse execute(String token, String paymentId);
}

public interface PaymentGatewayPort {
  MpPreferenceCreated createPreference(MpPreferenceCreate cmd);
  MpPayment getPayment(String paymentId);
}

public interface OrderStorePort {
  Optional<OrderEntity> findByOrderId(String orderId);
  OrderEntity save(OrderEntity order);
}

public interface PaymentStorePort {
  Optional<PaymentsEntity> findByPaymentIdForUpdate(String paymentId);
  PaymentsEntity save(PaymentsEntity payment);
}
```
Observação: nesta fase, manter `OrderEntity/PaymentsEntity` no port é aceitável como compromisso de baixo risco; desacoplamento total de modelo fica para fase futura.

## 4) Lista de mudanças por arquivo (cirúrgico)

1. **NOVO** [CreateCheckoutUseCase.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/application/payments/CreateCheckoutUseCase.java)  
Arquivo atual: N/A (**NOVO**)  
Mudança proposta: extrair lógica de criação de pedido + fallback estático + criação de preferência MP do `CheckoutService`.  
Motivação: mover regra para camada Application sem alterar contrato HTTP.  
Risco: duplicação temporária de regra durante transição.  
Rollback: controller volta a chamar `CheckoutService` legado.  
Teste associado: `CreateCheckoutUseCaseTest` (cenários token presente/ausente, notification URL inválida).

2. **NOVO** [ProcessMpWebhookUseCase.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/application/payments/ProcessMpWebhookUseCase.java)  
Arquivo atual: N/A (**NOVO**)  
Mudança proposta: centralizar validação de token/paymentId + chamada MP + delegação transacional.  
Motivação: reduzir acoplamento do controller e preparar fluxo para ports/adapters.  
Risco: mudança de orquestração interna pode alterar reason codes se não houver testes.  
Rollback: controller volta a chamar `MercadoPagoWebhookService`.  
Teste associado: `ProcessMpWebhookUseCaseTest` (invalid token, missing paymentId, mp_fetch_failed, approved/pending/rejected).

3. **NOVO** [PaymentGatewayPort.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/ports/payments/PaymentGatewayPort.java)  
Arquivo atual: N/A (**NOVO**)  
Mudança proposta: interface mínima para `createPreference` e `getPayment`.  
Motivação: remover dependência direta de `MercadoPagoClient` na aplicação.  
Risco: mapeamento incorreto entre records de porta e records MP.  
Rollback: use case injeta `MercadoPagoClient` diretamente (estado anterior).  
Teste associado: `MercadoPagoGatewayAdapterTest`.

4. **NOVO** [OrderStorePort.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/ports/payments/OrderStorePort.java)  
Arquivo atual: N/A (**NOVO**)  
Mudança proposta: wrapper mínimo para busca/salvamento de orders.  
Motivação: desacoplamento incremental de JPA repository.  
Risco: portar comportamento de save/update sem alterar semântica.  
Rollback: voltar a usar `OrderRepository` direto no service.  
Teste associado: `JpaOrderStoreAdapterIT`.

5. **NOVO** [PaymentStorePort.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/ports/payments/PaymentStorePort.java)  
Arquivo atual: N/A (**NOVO**)  
Mudança proposta: wrapper mínimo para `findByPaymentIdForUpdate` e `save`.  
Motivação: encapsular lock/idempotência atual em adapter.  
Risco: regressão de concorrência no webhook replay.  
Rollback: `MercadoPagoPaymentTxService` volta a usar `PaymentRepository` diretamente.  
Teste associado: `WebhookReplayConcurrencyIT`.

6. **NOVO** [MercadoPagoGatewayAdapter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/adapters/out/mercadopago/MercadoPagoGatewayAdapter.java)  
Arquivo atual: N/A (**NOVO**)  
Mudança proposta: adapter implementa `PaymentGatewayPort` delegando para `MercadoPagoClient`.  
Motivação: manter cliente HTTP existente e trocar apenas dependência do core.  
Risco: adapter mascarar exceções de forma diferente.  
Rollback: remove adapter e injeta `MercadoPagoClient` no use case.  
Teste associado: `MercadoPagoGatewayAdapterTest`.

7. **NOVO** [JpaOrderStoreAdapter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/adapters/out/persistence/JpaOrderStoreAdapter.java)  
Arquivo atual: N/A (**NOVO**)  
Mudança proposta: implementação de `OrderStorePort` via `OrderRepository`.  
Motivação: manter persistência atual intacta com boundary explícito.  
Risco: nenhum de contrato externo; risco interno baixo.  
Rollback: remover bean e voltar wiring antigo.  
Teste associado: `JpaOrderStoreAdapterIT`.

8. **NOVO** [JpaPaymentStoreAdapter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/adapters/out/persistence/JpaPaymentStoreAdapter.java)  
Arquivo atual: N/A (**NOVO**)  
Mudança proposta: implementação de `PaymentStorePort` via `PaymentRepository` mantendo lock pessimista.  
Motivação: preservar idempotência atual e isolar repositório.  
Risco: comportamento de race condition em `DataIntegrityViolation`.  
Rollback: restore direto para `PaymentRepository`.  
Teste associado: `WebhookReplayConcurrencyIT`.

9. [PaymentsController.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/api/PaymentsController.java:17)  
Arquivo atual: controller chama services diretamente.  
Mudança proposta: controller passa a injetar `CreateCheckoutUseCase` e `ProcessMpWebhookUseCase`; mantém paths, DTOs e extração de `paymentId` como hoje.  
Motivação: tornar controller thin e alinhar inbound adapter pattern.  
Risco: wiring de beans.  
Rollback: reverter injeção para services atuais.  
Teste associado: `PaymentsControllerContractTest` (snapshot de body/status).

10. [CheckoutService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/CheckoutService.java:24)  
Arquivo atual: contém regra completa de checkout.  
Mudança proposta: transformar em fachada delegando para use case ou marcar deprecated nesta fase.  
Motivação: rollback rápido e transição segura sem apagar código legado.  
Risco: dupla manutenção temporária.  
Rollback: voltar controller para esse service.  
Teste associado: `CheckoutServiceBackwardCompatTest` (opcional, simples).

11. [MercadoPagoWebhookService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoWebhookService.java:18)  
Arquivo atual: orquestra token/payment fetch/tx.  
Mudança proposta: virar fachada de compat delegando para `ProcessMpWebhookUseCase` ou manter apenas enquanto PR1->PR2.  
Motivação: migração Strangler com risco baixo.  
Risco: reason code divergente se lógica duplicada.  
Rollback: ativar caminho antigo pelo controller.  
Teste associado: `MercadoPagoWebhookServiceCompatTest` (opcional).

12. [MercadoPagoPaymentTxService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoPaymentTxService.java:20)  
Arquivo atual: usa `PaymentRepository` e `OrderRepository` direto.  
Mudança proposta: trocar dependências para `PaymentStorePort` e `OrderStorePort` mantendo regra de decisão/transição igual.  
Motivação: completar boundary hex na parte transacional sem reescrever lógica.  
Risco: regressão de lock/upsert.  
Rollback: voltar dependências concretas dos repositórios.  
Teste associado: `MercadoPagoPaymentTxServiceTest` + `WebhookReplayConcurrencyIT`.

## 5) Estratégia de migração sem quebrar nada

Aplicação do Strangler Fig:
1. Primeiro, controllers mudam apenas o destino interno (service -> use case), mantendo endpoint e DTO.
2. Em seguida, use cases trocam dependências concretas por ports, sem mexer no payload HTTP.
3. Serviços legados ficam como fallback temporário durante a fase para rollback rápido.

Garantias de compatibilidade:
- Endpoints mantidos: `/v1/payments/checkout` e `/v1/payments/mercadopago/notification` (GET/POST).
- DTOs mantidos: `CheckoutCreateRequest/Response`, `MercadoPagoWebhookResponse`.
- Códigos de status mantidos conforme comportamento atual.

Validação de compatibilidade:
- Contract tests com snapshots JSON de response body e status code.
- Execução de coleção Postman antes/depois (mesmos exemplos de payload).
- Diff automatizado de respostas críticas (`decision`, `reason`, `order.orderId`, `payment.id`).

## 6) Plano de testes Fase 1 (padrão fintech)

Unit tests (mock de ports):
1. `CreateCheckoutUseCaseTest`: cria order e retorna checkout URL com `accessToken` e sem `accessToken`.
2. `CreateCheckoutUseCaseTest`: erro quando `notificationUrl` ausente e token presente.
3. `ProcessMpWebhookUseCaseTest`: token inválido e `paymentId` ausente retornam `IGNORE`.
4. `ProcessMpWebhookUseCaseTest`: `approved` -> `PROVISION`; `pending` -> `WAIT_PAYMENT`; `rejected` -> `DENY`.
5. `MercadoPagoPaymentTxServiceTest`: `already_provisioned`, `order_canceled`, `amount_mismatch`, `CREATED -> PAID`.

Integration tests (Testcontainers + Postgres):
1. `WebhookReplayConcurrencyIT`: duas notificações simultâneas mesmo `paymentId`, 1 linha em `payments`, order consistente.
2. `WebhookOutOfOrderIT`: evento `pending` seguido de `approved` no mesmo `orderId`.
3. `CheckoutWebhookFlowIT`: checkout cria order, webhook aprovado marca order `PAID`.

Regressão de contrato:
1. `PaymentsControllerContractTest`: status/body de `POST /checkout`.
2. `PaymentsControllerContractTest`: status/body de `POST /notification`.
3. `PaymentsControllerContractTest`: comportamento de `GET /notification` com/sem API key conforme AS-IS.

## 7) Plano de PRs (mínimo 2 PRs)

### PR1 — estrutura + use cases + controllers thin
Escopo:
1. Criar pacote `com.shkgroups.application.payments`.
2. Adicionar **NOVO** `CreateCheckoutUseCase` e **NOVO** `ProcessMpWebhookUseCase`.
3. Alterar `PaymentsController` para chamar use cases.
4. Manter services legados como fallback temporário.

Checklist PR1:
1. Sem alteração de endpoint/path/DTO.
2. Sem alteração de migration/schema.
3. Contract tests de controller verdes.
4. `mvn test` verde.

### PR2 — ports + adapters mínimos + testes essenciais
Escopo:
1. Criar **NOVO** `PaymentGatewayPort`, `OrderStorePort`, `PaymentStorePort`.
2. Criar **NOVO** adapters JPA/MP.
3. Refatorar `MercadoPagoPaymentTxService` e use cases para usar ports.
4. Adicionar testes de concorrência webhook e regressão de contrato.

Checklist PR2:
1. Replays concorrentes do webhook sem duplicar efeito.
2. Reason codes críticos preservados.
3. `mvn test` verde com integration tests.
4. Rollback documentado por PR revert.

## 8) Checklist final de execução

Comandos:
1. `mvn clean test`
2. `mvn -Dtest=PaymentsControllerContractTest test`
3. `mvn -Dtest=WebhookReplayConcurrencyIT test`

Rotas validadas:
1. `POST /v1/payments/checkout` com payload válido e inválido.
2. `POST /v1/payments/mercadopago/notification?token=...&data.id=...`.
3. `GET /v1/payments/mercadopago/notification?...` (comportamento AS-IS de segurança preservado).

Rollback plan:
1. Reverter PR2 se houver regressão de concorrência/idempotência.
2. Reverter PR1 se houver regressão de contrato HTTP.
3. Durante a fase, manter services legados para fallback rápido de wiring interno.
