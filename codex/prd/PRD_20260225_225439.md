## 1) Executive Summary (10-15 linhas)
1. A Fase 1 existe para iniciar Clean/Hex (Ports & Adapters) no caminho crítico de pagamentos sem big-bang.
2. Escopo fechado: apenas `CreateCheckout` (`POST /v1/payments/checkout`) e `ProcessMercadoPagoWebhook` (`/v1/payments/mercadopago/notification` GET/POST).
3. Objetivo técnico: mover orquestração para Use Cases e deixar controllers thin.
4. Serão criadas apenas Ports mínimas: `PaymentGatewayPort`, `OrderStorePort`, `PaymentStorePort`.
5. Adapters iniciais serão wrappers do que já existe (`MercadoPagoClient`, `OrderRepository`, `PaymentRepository`).
6. NÃO muda nesta fase: paths, DTOs, formato de resposta, semântica externa do contrato.
7. NÃO entra nesta fase: redesign de domínio completo, troca de schema, dedup por `eventId`, refatoração global do projeto.
8. Compatibilidade é obrigatória: consumidores atuais (n8n/Postman/integrações) continuam funcionando sem ajuste.
9. Critério de sucesso: build e testes verdes (`mvn test`), testes de contrato estáveis, replay de webhook sem efeito duplicado.
10. Critério de segurança operacional: sem vazamento de segredos em logs novos, token continua validado server-side.
11. Estratégia de entrega: 2 PRs pequenos e mergeáveis, com rollback simples por `git revert`.
12. Toda adição será marcada como **NOVO**, com motivação, risco, impacto e rollback.

## 2) AS-IS — mapa de dependências REAL
### Fluxo 1: Checkout
Cadeia real: `PaymentsController.checkout` -> `CheckoutService.createCheckout` -> `OrderRepository.save` + `MercadoPagoClient.createPreference` + `MercadoPagoProperties`.

Referências:
[PaymentsController.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/api/PaymentsController.java)  
[CheckoutService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/CheckoutService.java)  
[MercadoPagoClient.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/mp/MercadoPagoClient.java)

Acoplamentos e riscos:
- Regra de negócio + persistência + integração externa no mesmo service.
- `@Transactional` envolve chamada HTTP externa (`WebClient.block()`), aumentando duração de transação.
- Dependência direta do service em `MercadoPagoProperties` e payload MP.
- Log de `notificationUrl` pode incluir token em query string.

Transações e side effects:
- Uma transação única cobre criação do pedido e caminho de integração.
- Side effects: insert em `orders`, chamada externa MP para preferência, resposta com `checkoutUrl`.
- Em erro de MP, comportamento atual tende a rollback global do método.

### Fluxo 2: Webhook
Cadeia real: `PaymentsController.mpNotification` -> `MercadoPagoWebhookService.process` -> `MercadoPagoClient.getPayment` -> `MercadoPagoPaymentTxService.handle` -> `PaymentRepository` + `OrderRepository`.

Referências:
[PaymentsController.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/api/PaymentsController.java)  
[MercadoPagoWebhookService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoWebhookService.java)  
[MercadoPagoPaymentTxService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoPaymentTxService.java)  
[PaymentRepository.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/PaymentRepository.java)

Acoplamentos e riscos:
- Validação de token, fetch no MP e decisão transacional espalhados.
- Caminho `no_external_reference` tenta `upsert` com `orderId=null`, mas `payments.order_id` é `NOT NULL`.
- Controller aceita GET/POST; segurança atual libera explicitamente POST (desalinhamento operacional).
- Idempotência depende de lock pessimista + unique em `payment_id`.

Transações e side effects:
- `getPayment` no MP ocorre fora da transação.
- `handle(...)` é transacional e faz upsert de `payments` + atualização de `orders` (`CREATED -> PAID`).
- Side effects principais: persistência de pagamento, transição de status de pedido, resposta `decision` para orquestração externa.

## 3) TO-BE Fase 1 — arquitetura alvo incremental (somente fase 1)
Diagrama textual:
```text
Controller (inbound HTTP)
  -> Use Case (Application)
    -> Ports (interfaces)
      -> Adapters (JPA / MercadoPago)
        -> Infra existente (repositories / webclient)
```

Pacotes novos:
- `com.shkgroups.application.payments` (use cases)
- `com.shkgroups.ports.payments` (interfaces)
- `com.shkgroups.adapters.out.mercadopago` (adapter do gateway)
- `com.shkgroups.adapters.out.persistence` (wrappers de JPA)

Use Cases **NOVO** (Fase 1):
- `CreateCheckoutUseCase`
- `ProcessMpWebhookUseCase`

Ports **NOVO** (mínimas):
- `PaymentGatewayPort`
- `OrderStorePort`
- `PaymentStorePort`

Assinaturas sugeridas (blueprint):
```java
public interface CreateCheckoutUseCase {
    CheckoutCreateResponse execute(CheckoutCreateRequest request);
}

public interface ProcessMpWebhookUseCase {
    MercadoPagoWebhookResponse execute(String token, String paymentId);
}

public interface PaymentGatewayPort {
    GatewayPreference createPreference(CreatePreferenceCommand command);
    GatewayPayment getPayment(String paymentId);
}

public interface OrderStorePort {
    OrderEntity save(OrderEntity order);
    Optional<OrderEntity> findByOrderId(String orderId);
}

public interface PaymentStorePort {
    Optional<PaymentsEntity> findByPaymentIdForUpdate(String paymentId);
    PaymentsEntity save(PaymentsEntity entity);
}
```

AS-IS vs TO-BE (Fase 1):
- AS-IS: controller chama service “god” com infra direta.
- TO-BE: controller chama use case; use case depende de port; adapter encapsula infra.
- AS-IS: acoplamento forte a `MercadoPagoClient`.
- TO-BE: uso via `PaymentGatewayPort`.
- AS-IS: repos JPA usados direto na regra.
- TO-BE: uso via `OrderStorePort`/`PaymentStorePort` sem mexer no schema.

## 4) Lista de mudanças por arquivo (cirúrgico)
1. **NOVO** [CreateCheckoutUseCase.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/application/payments/CreateCheckoutUseCase.java)  
Arquivo atual: inexistente.  
Mudança proposta: encapsular regra de checkout (criação de order, resolução de notification URL, chamada gateway, montagem de `CheckoutCreateResponse`).  
Motivação: mover regra para Application e deixar controller fino.  
Risco: divergência temporária se lógica coexistir com `CheckoutService`.  
Estratégia de rollback: controller volta a chamar `CheckoutService`.  
Teste associado: `CreateCheckoutUseCaseTest` (happy path, static checkout, config inválida, falha no gateway).  
Impacto: alto no desenho interno, zero no contrato externo.

2. **NOVO** [ProcessMpWebhookUseCase.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/application/payments/ProcessMpWebhookUseCase.java)  
Arquivo atual: inexistente.  
Mudança proposta: centralizar validação token/paymentId + fetch de pagamento + delegação transacional.  
Motivação: isolar fluxo webhook no core.  
Risco: alterar reason code sem querer.  
Estratégia de rollback: voltar para `MercadoPagoWebhookService`.  
Teste associado: `ProcessMpWebhookUseCaseTest` (invalid token, paymentId ausente, mp_fetch_failed, approved/pending/rejected).  
Impacto: médio interno, zero externo.

3. **NOVO** [PaymentGatewayPort.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/ports/payments/PaymentGatewayPort.java)  
Arquivo atual: inexistente.  
Mudança proposta: contrato mínimo para `createPreference` e `getPayment`.  
Motivação: desacoplar core do client MP.  
Risco: mapeamento adapter/port incorreto.  
Estratégia de rollback: use case injeta `MercadoPagoClient` direto.  
Teste associado: `MercadoPagoGatewayAdapterTest`.  
Impacto: baixo risco, habilita evolução futura.

4. **NOVO** [OrderStorePort.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/ports/payments/OrderStorePort.java)  
Arquivo atual: inexistente.  
Mudança proposta: wrapper mínimo de busca/salvamento de order.  
Motivação: boundary para persistência sem reescrever JPA.  
Risco: baixo.  
Estratégia de rollback: voltar para `OrderRepository` direto.  
Teste associado: `JpaOrderStoreAdapterIT`.  
Impacto: baixo, melhora testabilidade.

5. **NOVO** [PaymentStorePort.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/ports/payments/PaymentStorePort.java)  
Arquivo atual: inexistente.  
Mudança proposta: wrapper mínimo com lock pessimista e save.  
Motivação: preservar idempotência atual com abstração explícita.  
Risco: regressão de concorrência se lock for perdido.  
Estratégia de rollback: voltar para `PaymentRepository` direto.  
Teste associado: `WebhookReplayIT` com concorrência mínima.  
Impacto: médio em robustez.

6. **NOVO** [MercadoPagoGatewayAdapter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/adapters/out/mercadopago/MercadoPagoGatewayAdapter.java)  
Arquivo atual: inexistente.  
Mudança proposta: implementar `PaymentGatewayPort` delegando para `MercadoPagoClient`.  
Motivação: reaproveitar infra existente com mínimo risco.  
Risco: propagação de exceção diferente do legado.  
Estratégia de rollback: remover adapter e injetar client direto.  
Teste associado: `MercadoPagoGatewayAdapterTest`.  
Impacto: baixo.

7. **NOVO** [JpaOrderStoreAdapter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/adapters/out/persistence/JpaOrderStoreAdapter.java)  
Arquivo atual: inexistente.  
Mudança proposta: implementar `OrderStorePort` com `OrderRepository`.  
Motivação: anti-corruption layer mínima para futura clean domain.  
Risco: baixo.  
Estratégia de rollback: wiring para repo direto.  
Teste associado: `JpaOrderStoreAdapterIT`.  
Impacto: baixo.

8. **NOVO** [JpaPaymentStoreAdapter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/adapters/out/persistence/JpaPaymentStoreAdapter.java)  
Arquivo atual: inexistente.  
Mudança proposta: implementar `PaymentStorePort` com `PaymentRepository`, mantendo `findByPaymentIdForUpdate`.  
Motivação: garantir semântica de idempotência atual.  
Risco: médio (concorrência).  
Estratégia de rollback: wiring antigo.  
Teste associado: `WebhookReplayIT`.  
Impacto: médio.

9. [PaymentsController.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/api/PaymentsController.java)  
Arquivo atual: controller chama services diretamente.  
Mudança proposta: injetar `CreateCheckoutUseCase` e `ProcessMpWebhookUseCase`; manter paths e DTOs atuais.  
Motivação: controller thin (inbound adapter).  
Risco: erro de DI/wiring.  
Estratégia de rollback: reverter para services antigos.  
Teste associado: `PaymentsControllerContractTest` (status/body snapshot).  
Impacto: zero em contrato HTTP.

10. [MercadoPagoPaymentTxService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoPaymentTxService.java)  
Arquivo atual: usa `OrderRepository` e `PaymentRepository` diretamente.  
Mudança proposta: trocar dependências para `OrderStorePort`/`PaymentStorePort` sem alterar regras de decisão; bloquear persistência quando `externalReference` ausente para evitar write inválido.  
Motivação: completar boundary de persistência e reduzir risco de inconsistência.  
Risco: alterar comportamento interno em casos limítrofes de replay.  
Estratégia de rollback: restabelecer repos diretos e fluxo original.  
Teste associado: `MercadoPagoPaymentTxServiceTest` + `WebhookReplayIT`.  
Impacto: melhora robustez sem alterar DTO de resposta.

11. [CheckoutService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/CheckoutService.java)  
Arquivo atual: regra completa no service.  
Mudança proposta: manter como facade temporária/deprecated delegando ao use case (opcional para rollback rápido).  
Motivação: Strangler incremental reversível.  
Risco: duplicidade temporária.  
Estratégia de rollback: controller aponta novamente para service legado.  
Teste associado: smoke de compatibilidade de bean/contexto.  
Impacto: interno apenas.

12. [MercadoPagoWebhookService.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/payments/MercadoPagoWebhookService.java)  
Arquivo atual: contém parte da orquestração.  
Mudança proposta: reduzir para facade/delegator ao use case durante transição.  
Motivação: evitar big-bang e facilitar revert.  
Risco: dupla rota lógica se coexistirem caminhos.  
Estratégia de rollback: reativar implementação atual integralmente.  
Teste associado: testes de contrato do endpoint webhook.  
Impacto: zero externo.

13. [SecurityConfig.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/security/SecurityConfig.java) e [ApiKeyAuthFilter.java](/mnt/c/repositorio/com.shkgroups.agent/src/main/java/com/shkgroups/security/ApiKeyAuthFilter.java)  
Arquivo atual: bypass explícito para POST no webhook.  
Mudança proposta: alinhar whitelist com controller (`GET` e `POST` no mesmo path), mantendo validação de token no use case.  
Motivação: coerência contrato declarado vs segurança efetiva.  
Risco: exposição indevida se token validation falhar.  
Estratégia de rollback: restringir novamente a POST.  
Teste associado: `WebhookSecurityContractTest` (GET/POST sem API key, token inválido, token válido).  
Impacto: compatibilidade operacional melhor, sem mudar path/DTO.

14. **NOVO** [PaymentsControllerContractTest.java](/mnt/c/repositorio/com.shkgroups.agent/src/test/java/com/shkgroups/payments/api/PaymentsControllerContractTest.java), **NOVO** [CreateCheckoutUseCaseTest.java](/mnt/c/repositorio/com.shkgroups.agent/src/test/java/com/shkgroups/application/payments/CreateCheckoutUseCaseTest.java), **NOVO** [ProcessMpWebhookUseCaseTest.java](/mnt/c/repositorio/com.shkgroups.agent/src/test/java/com/shkgroups/application/payments/ProcessMpWebhookUseCaseTest.java), **NOVO** [WebhookReplayIT.java](/mnt/c/repositorio/com.shkgroups.agent/src/test/java/com/shkgroups/payments/WebhookReplayIT.java)  
Arquivo atual: cobertura insuficiente para contratos e replay.  
Mudança proposta: suíte mínima P0 de unit + contract + integração.  
Motivação: proteger contra regressão na extração incremental.  
Risco: custo inicial de setup.  
Estratégia de rollback: manter apenas unit/contract se IT bloquear pipeline temporariamente.  
Teste associado: os próprios arquivos.  
Impacto: alto em confiança de merge.

15. [pom.xml](/mnt/c/repositorio/com.shkgroups.agent/pom.xml)  
Arquivo atual: sem Testcontainers.  
Mudança proposta: adicionar dependências de teste para `junit-jupiter` + `postgresql` (Testcontainers) na Fase 1 PR2.  
Motivação: validar concorrência/idempotência em banco real.  
Risco: pipeline sem Docker.  
Estratégia de rollback: desabilitar IT por profile e manter contract tests.  
Teste associado: `WebhookReplayIT`.  
Impacto: qualidade de validação.

## 5) Estratégia de migração sem quebrar nada
1. Aplicar Strangler Fig: endpoint e DTO ficam iguais; só a implementação interna troca de service para use case.
2. Manter `PaymentsController` no mesmo path e assinatura HTTP.
3. Introduzir use case primeiro, com comportamento idêntico ao legado (golden tests).
4. Introduzir ports/adapters depois, sem alterar response model.
5. Preservar reason codes e status codes atuais; qualquer mudança de contrato fica marcada como FUTURA (fora da Fase 1).
6. Validar compatibilidade com três camadas: `MockMvc contract tests`, snapshots JSON de respostas e coleção Postman existente.
7. Executar testes de regressão antes/depois da troca de wiring (mesmo payload, mesmo body/status esperado).

## 6) Plano de testes Fase 1 (padrão fintech)
1. Unit tests (mock ports):
- `CreateCheckoutUseCaseTest`: pedido criado, fallback static URL, falha config/token, exceção gateway.
- `ProcessMpWebhookUseCaseTest`: token inválido, paymentId ausente, fetch falho, decisões por status MP.
- `MercadoPagoPaymentTxServiceTest`: `CREATED->PAID`, `already_provisioned`, `order_canceled`, `amount_mismatch`.

2. Integration tests (preferência: Testcontainers + Postgres):
- `WebhookReplayIT`: duas execuções com mesmo `paymentId` não duplicam pagamento.
- Concorrência mínima: duas threads processando mesmo `paymentId` validando lock + unique constraint.
- Caso sem `external_reference`: não deve causar efeito colateral inválido.

3. Regressão de contrato:
- `POST /v1/payments/checkout`: validar `200` e body com `orderId`, `checkoutUrl`, `messageText`.
- `GET|POST /v1/payments/mercadopago/notification`: validar `200` e body `decision/reason/payment`.
- Snapshot de bodies para payloads conhecidos e comparação byte-a-byte (ou JSON canonical).

## 7) Plano de PRs (mínimo 2 PRs)
**PR1 — Estrutura Application + controllers thin**
- Escopo: criar pacotes `application` e use cases **NOVO**; controller passa a delegar para use cases; manter services legados como fallback.
- Checklist de validação:
- [ ] `mvn test` verde.
- [ ] Sem mudança de endpoint/path/DTO.
- [ ] `PaymentsControllerContractTest` cobrindo checkout + webhook.
- [ ] Rollback documentado (reverter wiring para services).

**PR2 — Ports + adapters mínimos + testes essenciais**
- Escopo: criar ports **NOVO**, adapters JPA/MP **NOVO**, migrar `MercadoPagoPaymentTxService` para ports, adicionar IT de replay/concurrency.
- Checklist de validação:
- [ ] `mvn test` verde com unit + contract.
- [ ] `WebhookReplayIT` verde (ou profile dedicado `-Pit`).
- [ ] Sem diffs de contrato HTTP nos snapshots.
- [ ] Rollback documentado por `git revert` do PR2 isoladamente.

## 8) Checklist final de execução
- `mvn -q clean test`
- `mvn -q -Dtest=PaymentsControllerContractTest test`
- `mvn -q -Dtest=CreateCheckoutUseCaseTest,ProcessMpWebhookUseCaseTest test`
- `mvn -q -Dtest=WebhookReplayIT test` (com Docker ativo, se Testcontainers)
- Rotas validadas:
- `POST /v1/payments/checkout`
- `GET /v1/payments/mercadopago/notification?token=...&data.id=...`
- `POST /v1/payments/mercadopago/notification?token=...` com body MP
- Rollback plan:
- `git revert <commit_PR2>` restaura adapters/ports e mantém PR1.
- `git revert <commit_PR1>` volta totalmente ao AS-IS.
- Nenhuma migração Flyway nova nesta Fase 1, então rollback é somente de código.
